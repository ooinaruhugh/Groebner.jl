
@def title = "Groebner.jl â€” Tutorial"
@def hasmath = true
@def hascode = true
<!-- Note: by default hasmath == true and hascode == false. You can change this in
the config file by setting hasmath = false for instance and just setting it to true
where appropriate -->

# Tutorials

```julia:installs
import Pkg # hide
import Pkg; Pkg.add("BenchmarkTools") # hide
Pkg.add("Graphs") # hide
Pkg.add("GraphPlot") # hide
Pkg.add("AbstractAlgebra") # hide
Pkg.add(url="https://github.com/sumiya11/Groebner.jl") # hide
Pkg.add("DynamicPolynomials") # hide
Pkg.add("AbstractAlgebra") # hide
Pkg.add("Compose") # hide
using Groebner # hide
using AbstractAlgebra # hide
using BenchmarkTools # hide
using Graphs # hide
using GraphPlot # hide
using Compose # hide
```
## Introduction

The following contains a series of tutorials that illustrate interesting usecases of Groebner bases provided with the code from Groebner.jl.

In particular, these notes are intended as a non-rigorus introduction to the notion of Groebner bases.

We also refer to the [Tutorial by Michael Stillman](https://www3.risc.jku.at/research/theorema/Groebner-Bases-Bibliography/gbbib_files/publication_190.pdf) that covers similar examples but in much more detail.

<!-- Introduced by Buchberger in 1965 for handling quotient space of ideals algorithmically, Groebner bases are excellent for **variable elimination, system solving**, and many more. Among others, Groebner bases find applications in

- Robotics
- Chemical Reactions Networks Analysis
- Control Theory
- Cryptography

The following tutorials will give a short introduction to Groebner basis ground theory, and cover some random interesting showcases. -->

### So, what is a Groebner basis?

*In short, Groebner basis is a good representation of infinite information.*

Let us recall some theory from an algebra course. A set of polynomials $F = \{f_1, \ldots, f_m \}$ is said to generate the ideal $I$ if

\[
  I = \{ f_1h_1 + f_2h_2 + \ldots + f_mh_m ~~|~~ h_i ~~\text{arbitrary polynomials} \}.
\]

Notice that $I$ can be infinite. Informally, the ideal encodes all algebraic relations between polynomials $f_1, \ldots, f_m$.

A Groebner basis of $I$ is a *nicer set of generators* for $I$. For example, let

```julia:aaimport
using AbstractAlgebra

_, (x, y) = QQ["x", "y"]
F = [x^3 + y^2, x*y + x^2]
```

In this example, the Groebner basis of `F` is

```julia:exampleone
using Groebner
groebner(F)
```

But why is it *nice*?

First of all, the Groebner basis is *unique*! That is, if two sets of polynomials $F_1$ and $F_2$ generate the same ideal (which is actually infinite), then their Groebner bases (which are finite) are the same and can be compared directly

```julia:unique
F2 = [
  x^6 + 2*x^3*y^2 + y^4,
  x^3 - x^2*y^3 - x*y^4 + y^2,
  x^2 + x*y
]
# the ideals generated by F and F2 coincide
groebner(F) == groebner(F2)
```

So, Groebner bases provide a **unique and finite** representation of symbolic systems, combinatorial relations, varieties, and everything else that can be encoded with polynomials. 

Moreover, every ideal generated by a finite set of polynomials has a Groebner basis[^1]. 
Thus, Groebner basis is a universal tool that can be used to draw conclusions about polynomial ideals, as we will see in the next sections.

## Gcd & Ref

Computing a Groebner basis for a general system of nonlinear polynomials can be nontrivial. 
Still, two known algorithms may give us some intuition behind this process.

### Groebner basis is Gaussian Elimination

For linear systems, Groebner basis is Row echelon form. 

This is due to the fact that in the process of computing a Groebner basis polynomials are repeatedly reduced by each other until a certain condition is met, and in case polynomials are linear, polynomial reduction coincides with Gaussian elimination.

```julia:gauss
using DynamicPolynomials

@polyvar x y z
system = [
  x - y + z + 1,
  x + 2y + 3z + 4,
  x + y + 5z + 3
]

groebner(system)  # rref
```

This implies $z = 0, ~y = -1, ~x = -2$.

### Groebner basis is Euclidean Algorithm

For univariate systems, Groebner basis is Greatest common divisor.

This is so since the ideal $I$ generated by univariate $f_1(x), f_2(x)$ is principal:
any $h_1f_1 + h_2f_2 \in I$ can be expressed as a multiple of a single polynomial $f(x)$, where $f(x) = gcd(f_1(x), f_2(x))$. So, we have the equality of ideals

$$
\{h_1f_1 + h_2f_2\} = \{ hf \} ~~~ | ~~~ h_1,h_2,h ~~\text{are arbitrary}.
$$

```julia:gcd1
using DynamicPolynomials # hide
@polyvar x
f = (x^2 - 1)^7*(x + 3)*(x - 7)^4
g = (x + 3)*(x + 7)

groebner([f, g])   # gcd by groebner
```

```julia:gcd2
gcd(f, g)          # usual gcd
```

Naturally, the same holds for several input polynomials:

\[
groebner(f_1, \ldots, f_m) = gcd(gcd(gcd(f_1, f_2), \ldots), f_m)
\]

So, you can compute the GCD of several polynomials at once using Groebner.jl (but you probably should not)!

We take this chance to demonstrate that Groebner.jl has only a small runtime overhead over the classic GCD implementation.

With `DynamicPolynomials.jl`:

```julia:gcd3
h = (x + 3)^5

@btime gcd(gcd($f, $g), $h)
```

With Groebner.jl:

```julia:gcd4
F = [f, g, h]
@btime groebner($F)
```

## Variable Elimination

One can also use Groebner bases to *eliminate indeterminates* from equations. A layer of theory lies behind this topic, however, the main simple observation here is that

***

If $G$ is a Groebner basis of ideal $I$ with variables ordered as $x > y > z$, then

\[
G \cap R[y, z]
\]

is a Groebner basis for $I_{y, z}~ =~ I \cap R[y, z]$.

***

Here, one can see $I_{y, z}$ as a fair geometric projection of $I$ onto the last two variables $y, z$.

For example, consider polynomial set $F$ that encodes some complicated algebraic variety in 3D:

```julia:elim1
_, (x, y, z) = QQ["x", "y", "z"]

F = [x + y^2 + z - 1,
     x + y + z^2 - 1]
```

<!-- Plotted, this variety looks like

[PLOT of in 3D] -->

Let's try to simplify it a bit. Now, the Groebner basis of $F$ is

```julia:elim2
G = groebner(F)
```

Notice that the first polynomial in  `G` does not contain `x`! The observation implies that `G[1]` is a Groebner basis of $I_{y, z}$, meaning the solutions of

\[
y^2 - y - z^2 + z = 0
\]

are exactly the projection of solutions of $F$ to variables $y$ and $z$.

<!-- Let us plot the solutions of `G[1]` -->

With this technique, one can split a complicated variety in parts, and treat each part separately.

## Curve Implicitization

<!-- \note{For some reason Tex in this subsection is not compiled properly.} -->

Moreover, Groebner.jl can help converting a parametric curve representation to an implicit one. Say, we have a parametrization of *the circle on a plane*

\[\left\{\begin{aligned}
x = \frac{1 - t^2}{1 + t^2},\\
y = \frac{2t}{1 + t^2}
\end{aligned}\right.\]

and we want to produce an implicit curve equation in $x, y$ and *without t*.

First, let's clear denominators

\[\left\{\begin{aligned}
t^2y - 2t + y = 0,\\
t^2x + t^2 + x - 1 = 0
\end{aligned}\right.\]

The Groebner basis of the above with $t > x > y$ in lexicographic order is

```julia:impl1
using AbstractAlgebra
_, (t, x, y) = polynomial_ring(QQ, ["t", "x", "y"], ordering=:lex)

groebner([t^2*y - 2t + y, t^2*x + t^2 + x - 1])
```

There, the only two-variable equation in $x, y$ is

\[
x^2 + y^2 - 1 = 0
\]

Hence, $x^2 + y^2 - 1 = 0$ is an implicit formula we were looking for. Indeed, for any $t$ every $(x, y)$ lies on the circle as expected.

## Solving Systems

Groebner bases can be used to solve systems *exactly*, given the number of solutions is finite.

In this section we assume the usual lexicographic ordering of variables and consider the case with three variables (i.e, $x > y > z$). Same method generalizes naturally for $n$ indeterminates.

```julia:sys0
_, (x, y, z) = polynomial_ring(QQ, ["x", "y", "z"], ordering=:lex);
```

To illustrate the method, we consider the following polynomial system to solve

```julia:sys1
system = [x + y + z,
          x*y + x*z + y*z,
          x*y*z - 1];
```

Recall that the solutions of a system coincide with zeros of a Groebner basis of this system (since the original system and its basis are *equivalent*). Let's calculate a Groebner basis then!

```julia:sys2
groebner(system)
```

Notice that `z^3 - 1` in the basis is a *univariate equation*. Solving it over the desired domain one obtains some roots `z = ...`.

Then, substitute `z` into the second equation `y^2 + y*z + z^2`, which in turn becomes univariate in variable `y`. Solving it and obtaining zeros in `y`, one moves to the next equation in the basis.

Substituting each `y` and `z` to `x + y + z`, one easily produces a single solution in `x` for each solution in `y, z`.  

Solving general polynomial systems (assuming the set of solutions is finite) using Groebner bases relies on the same technique:

1. In the Groebner basis there is a univariate equation;
2. Solve it, and substitute found roots into other equations;
3. Go to 1.

## Integer Programming

\note{This cool example is adapted from [Christopher Hillar
(MSRI) presentation](https://people.math.carleton.ca/~cingalls/studentProjects/alithesis.pdf) on Groebner Bases.}

Integer programming is the problem of solving linear equations where the solution must be in non-negative integers and should minimize a given "cost function".

Our strategy here is to convert the integer programming problem into a problem about polynomials, and then solve this polynomial problem using Groebner bases.

*The classic example problem is the following.* Say we have coins of 4 nominal values: pennies $P$, nickels $N$, dimes $D$, and quarters $Q$. We want to pick a collection that amounts to 117 using the least number of coins possible.

In other words, minimize $P + N + D + Q$ subject to $P, N, D, Q \ge 0$ and

$$
P + 5N + 10D + 25Q = 117
$$

The minimal integer solution is $(P, N, D, Q) = (2, 1, 1, 4)$, let's try to find it with Groebner bases.

First, we will represent each collection of coins by a polynomial $p^an^bd^cq^d$ in variables $p, n, d, q$ (e.g., 2 pennies with 5 dimes is $p^2d^5$).

We also know that $p^5$ is the same as $n$, $p^{10}$ is the same as $d$, and so on. The full set of constraints is

\[
F = \{p^5 - n, p^10 - d, p^25 - q\}
\]

The idea is to construct a more useful set of constraints using a Groebner basis

```julia:coins1
_, (p, n, d, q) = polynomial_ring(QQ, ["p","n","d","q"], ordering=:deglex)

F = [p^5 - n, p^10 - d, p^25 - q]   # initial constraints

G = groebner(F)   # more nice and useful constraints
```

\note{Notice that we construct polynomials in `deglex` ordering, instead of the default `lex`.}

These new constraints express a useful set of replacement (rewrite) rules. E.g., the expression `d^3 - n*q` in the basis translates to: replace 3 dimes with a nickel and a quarter.

Now, we take an arbitrary solution (not necessarily minimal), say $p^{17}n^{10}d^5$, and compute the normal form w.r.t. $G$

```julia:coins2
normalform(G, p^17*n^10*d^5)
```

to obtain the minimial solution $(P, N, D, Q) = (2, 1, 1, 4)$.

## Graph Coloring

In graph theory, Graph coloring is a problem of assigning a color to each vertex of a graph in a way that no two neighboring vertices the same color.

```julia:graph0
using Graphs # hide
using GraphPlot # hide
g = Graph(4) # hide
add_edge!(g, 1, 2); # hide
add_edge!(g, 1, 3); # hide
add_edge!(g, 1, 4); # hide
add_edge!(g, 2, 3); # hide
add_edge!(g, 3, 4); # hide
```

```julia:graph1
# hideall
xs = [0.5, 1.0, 0.5, 0.0]
ys = [-sqrt(3) / 6, 0.0, -1.0, 0.0]
nodelabeldist = 1.5
nodelabel = collect(1:4)
draw(SVG(joinpath(@OUTPUT, "graph2.svg"), 16cm, 16cm), gplot(g, xs, ys, nodelabel=nodelabel, nodelabeldist=nodelabeldist));
```

\fig{graph2}

The common hard question is *the existence of a proper coloring with $k$ colors* for $k > 2$. In this section, we will show how the question can be tackled using the Groebner bases approach.

The approach is to

- Establish relation between *k-coloring* and *system of polynomial equations*
- Solve the system or prove unsolvable

There are two types of polynomials forming a typical graph coloring system.

First, for each vertex $j$ in a graph we assign variable $x_j$. To fix that each particular vertex $j$ has a color we construct *vertex polynomials* of form

\[
x_j^k - 1 = 0
\]

for each vertex $j$. Then one color out of $k$ is represented as one of the $k$-th roots of unity.

Secondly, we add *edge polynomials*

\[
\frac{x_i^k - x_j^k}{x_i - x_j}
\]

for each $i \rightarrow j$ in edges to ensure two neighboring vertices do not share the same color. Such polynomial disallows that colors  $x_i$ and $x_j$ for two neighbors $i$ and $j$ coincide. Finally, solutions of a system constructed this way correspond to proper k-colorings in a 1 to 1 relation.

For example, the coloring system for k=3 in the graph above must contain vertex polynomials

\[
\{ x_1^3 - 1,~ x_2^3 - 1,~ x_3^3 - 1,~ x_4^3 - 1 \}
\]

and a bunch of edge polynomials. Note that adding an edge polynomial $\frac{x_i^3 - x_j^3}{x_i - x_j}$ to a system is equivalent to adding $x_i^2 + x_ix_j + x_j$ to it.

Now consider the resulting coloring system for the graph from the picture

```julia:graph3
_, (x1, x2, x3, x4) = QQ["x1","x2","x3","x4"]

coloring_system = [
  x1^3 - 1, x2^3 - 1, x3^3 - 1, x4^3 - 1,
  x1^2 + x1*x2 + x2^2,
  x1^2 + x1*x3 + x3^2,
  x1^2 + x1*x4 + x4^2,
  x2^2 + x2*x3 + x3^2,
  x3^2 + x3*x4 + x4^2
]

groebner(coloring_system)
```

From the `x2 - x4` equation in the basis we understand 2nd and 4th vertices should be of the same color. It only remains to assign colors to the remaining vertices

```julia:graph4
# hideall
nodefillc = ["red", "blue", "green", "blue"]

xs = [0.5, 1.0, 0.5, 0.0]
ys = [-sqrt(3) / 6, 0.0, -1.0, 0.0]
nodelabeldist = 1.5
nodelabel = collect(1:4)
draw(SVG(joinpath(@OUTPUT, "graphcolored.svg"), 16cm, 16cm), gplot(g, xs, ys, nodelabel=nodelabel, nodelabeldist=nodelabeldist, nodefillc=nodefillc));
```

\fig{graphcolored}

[^1]: See, for example, Theorem 2.4.6 in the wonderful book "Computational Commutative Algebra 1" by Martin Kreuzer and Lorenzo Robbiano [https://link.springer.com/book/10.1007/978-3-540-70628-1](https://link.springer.com/book/10.1007/978-3-540-70628-1).
